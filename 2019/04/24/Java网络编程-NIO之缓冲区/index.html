<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><meta name="theme-color" content="#2d4356"><meta name="baidu-site-verification"><title>Java网络编程-NIO之缓冲区 | willardteriberka</title><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.png"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="willardteriberka" type="application/atom+xml">
</head><link rel="stylesheet" type="text/css" href="/plugins/prettify/doxy.css"><script type="text/javascript" src="/js/ready.js" async></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><body class="night"><div class="mobile-head" id="mobile-head"><div class="navbar-icon"><span></span><span></span><span></span></div><div class="navbar-title"><a href="/">LITREILY</a></div><div class="navbar-search"><!--= show a circle here--></div></div><div class="h-wrapper" id="menu"><nav class="h-head box"><div class="m-hdimg"><a class="hdimg img" href="/"><img class="nofancybox" src="/img/profile.jpg" width="128" height="128"></a><h1 class="ttl"><a href="/">willardteriberka</a></h1></div><p class="m-desc">The difference between people is involved in the spare time.<br>----------Einstein</br></p><div class="m-nav"><ul><li><span class="dot">●</span><a href="/archives/">归档</a></li><li><span class="dot">●</span><a href="/categories/">分类</a></li><li><span class="dot">●</span><a href="/tags/">标签</a></li><li><span class="dot">●</span><a href="/about/">关于</a></li><li><span class="dot">●</span><a href="/atom.xml">RSS</a></li><li class="m-sch"><form class="form" id="j-formsch" method="get"><input class="txt" type="text" id="local-search-input" name="q" value="搜索" onfocus="if(this.value=='搜索'){this.value='';}" onblur="if(this.value==''){this.value='搜索';}"><input type="text" style="display:none;"></form></li></ul><div id="local-search-result"></div></div></nav></div><div id="back2Top"><a class="fa fa-arrow-up" title="Back to top" href="#"></a></div><div class="box" id="container"><div class="l-wrapper"><div class="l-content box"><div class="l-post l-post-art"><article class="p-art"><div class="p-header box"><h1 class="p-title">Java网络编程-NIO之缓冲区</h1><div class="p-info"><span class="p-date"><i class="fa fa-calendar"></i><a href="/2019/04/24/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-NIO%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA/">2019-04-24</a></span><span class="p-category"><i class="fa fa-folder"></i><a href="/categories/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">Java网络编程</a></span><span class="p-view" id="busuanzi_container_page_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_page_pv"></span></span></div></div><div class="p-content"><p>NIO的基础要素是缓冲区、通道、选择器。本篇文章讲述缓冲区的部分。</p>
<!-- toc -->

<h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><h2 id="NIO概念"><a href="#NIO概念" class="headerlink" title="NIO概念"></a>NIO概念</h2><p>同步和和非同步、阻塞和非阻塞。</p>
<p>同步阻塞 一直排队，直到处理到数据为止。</p>
<p>同步非阻塞 如果处理需要排队，则不进行。</p>
<p>异步非阻塞 不排队有监听，监听到目标条件则调用回调函数。</p>
<p>在 Java 7 中，NIO 有了进一步的改进，也就是 NIO 2，引入了异步非阻塞 IO 方式，也有很多人叫它 AIO（Asynchronous IO</p>
<p>NIO由三部分组成：缓冲区(buffer)、通道(channel)、选择器(Selector) 在访问个数特别大的时候才使用的。</p>
<h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p>作用: 在NIO中，就是通过 Buffer 来读写数据的。所有的数据都是用Buffer来处理的，它是NIO读写数据的中转池, 通常使用字节数组。</p>
<h3 id="buffer的种类"><a href="#buffer的种类" class="headerlink" title="buffer的种类"></a>buffer的种类</h3><ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
<li>没有Boolean类型的缓冲区</li>
</ul>
<h3 id="缓冲区的种类："><a href="#缓冲区的种类：" class="headerlink" title="缓冲区的种类："></a>缓冲区的种类：</h3><ul>
<li><p>在堆中创建缓冲区称为：间接缓冲区</p>
</li>
<li><p>在系统内存创建缓冲区称为：直接缓冲区</p>
</li>
<li><p>间接缓冲区的创建和销毁效率要高于直接缓冲区</p>
</li>
<li><p>间接缓冲区的工作效率要低于直接缓冲区</p>
</li>
</ul>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li>创建缓冲区<ul>
<li>static ByteBuffer allocate(int capacity)构造方法 在堆内存中创建一个byte类型的buffer缓冲区，参数为该缓冲区的长度</li>
<li>static ByteBuffer allocateDirect(int capacity) 构造方法 在系统内存中创建一个byte类型的buffer缓冲区，参数为该缓冲区的长度</li>
<li>public static ByteBuffer wrap(byte[] array) 通过数组在堆内存创建buffer间接缓冲区</li>
</ul>
</li>
<li>添加数据<ul>
<li>public ByteBuffer put(byte b)：向当前可用位置添加数据。</li>
<li>public ByteBuffer put(byte[] byteArray)：向当前可用位置添加一个byte[]数组</li>
<li>public ByteBuffer put(byte[] byteArray,int offset,int len)：添加一个byte[]数组的一部分到缓冲区的当前可用位置。</li>
</ul>
</li>
<li>容量<ul>
<li>public final int capacity() : 返回此缓冲区的容量。 </li>
</ul>
</li>
<li>限制<ul>
<li>public int limit()：获取此缓冲区的限制。</li>
<li>public Buffer limit(int newLimit)：设置newLimit表示索引为此缓冲区的限制。限制之后只能使用限制索引以前的内容。</li>
</ul>
</li>
<li>位置<ul>
<li>public int position()：获取当前可写入位置索引。</li>
<li>public Buffer position(int p)：更改当前可写入位置索引。不能大于limit方法设置的限制索引。设置完之后只有范围是position的位置到limit的位置可用</li>
</ul>
</li>
<li>标记<ul>
<li>public Buffer mark()：设置此缓冲区的标记为当前的position位置。</li>
</ul>
</li>
<li>操作buffer方法</li>
<li>public Buffer reset() : 将此缓冲区的position位置重置为以前标记的位置。</li>
<li>public int remaining()：获取position与limit之间的元素数。</li>
<li>public boolean isReadOnly()：获取当前缓冲区是否只读。</li>
<li>public boolean isDirect()：获取当前缓冲区是否为直接缓冲区。</li>
<li>public Buffer rewind()：重绕此缓冲区。将position位置设置为：0，限制limit不变。丢弃标记。</li>
<li>public Buffer clear()：还原缓冲区的状态。将position设置为：0将限制limit设置为容量capacity；丢弃标记mark。数据保留。</li>
<li>public Buffer flip()：缩小limit的范围。将limit设置为当前position位置；将当前position位置设置为0；丢弃mark。数据保留。</li>
</ul>
<p>推荐使用字节缓冲区</p>
<h4 id="创建缓冲区"><a href="#创建缓冲区" class="headerlink" title="创建缓冲区"></a>创建缓冲区</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocateDirect(<span class="number">10</span>);</span><br><span class="line">ByteBuffer byteBuffer = byteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">ByteBuffer byteBuffer = byteBuffer.wrap(bytes);</span><br></pre></td></tr></table></figure>

<h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer b1 = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 添加数据</span></span><br><span class="line">b1.put((<span class="keyword">byte</span>) <span class="number">11</span>);</span><br><span class="line">b1.put((<span class="keyword">byte</span>) <span class="number">12</span>);</span><br><span class="line">b1.put((<span class="keyword">byte</span>) <span class="number">13</span>);</span><br></pre></td></tr></table></figure>

<h4 id="容量（capacity）"><a href="#容量（capacity）" class="headerlink" title="容量（capacity）"></a>容量（capacity）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer b1 = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">System.out.println(b1.limit());<span class="comment">//使用limit方法打印当前缓冲区容量。 结果： 10</span></span><br></pre></td></tr></table></figure>

<p>Buffer的容量(capacity)是指：Buffer所能够包含的元素的最大数量。定义了Buffer后，容量是不可变的。</p>
<h4 id="限制（limit）"><a href="#限制（limit）" class="headerlink" title="限制（limit）"></a>限制（limit）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer b1 = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;限制前容量: &quot;</span> + b1.limit());<span class="comment">//10</span></span><br><span class="line">b1.limit(<span class="number">5</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;限制后容量: &quot;</span> + b1.limit());<span class="comment">//5</span></span><br></pre></td></tr></table></figure>

<p>设置限制后在限制范围外添加数据会报BufferOverflowException异常。</p>
<h4 id="位置（position）"><a href="#位置（position）" class="headerlink" title="位置（position）"></a>位置（position）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer b1 = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">b1.put((<span class="keyword">byte</span>) <span class="number">11</span>);</span><br><span class="line">b1.put((<span class="keyword">byte</span>) <span class="number">12</span>);</span><br><span class="line">b1.put((<span class="keyword">byte</span>) <span class="number">13</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;设置位置前:&quot;</span>+Arrays.toString(b1.array()));</span><br><span class="line">System.out.println(b1.toString());</span><br><span class="line">b1.position(<span class="number">5</span>);</span><br><span class="line">b1.put((<span class="keyword">byte</span>) <span class="number">14</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;设置位置后:&quot;</span>+Arrays.toString(b1.array()));</span><br><span class="line">System.out.println(b1.toString());</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">设置位置前:[11, 12, 13, 0, 0, 0, 0, 0, 0, 0]</span><br><span class="line">java.nio.HeapByteBuffer[pos=3 lim=10 cap=10]</span><br><span class="line">设置位置后:[11, 12, 13, 0, 0, 14, 0, 0, 0, 0]</span><br><span class="line">java.nio.HeapByteBuffer[pos=6 lim=10 cap=10]</span><br></pre></td></tr></table></figure>

<p>通俗的理解位置就是下个元素要插入的位置。</p>
<h4 id="mark（标记）-amp-reset方法"><a href="#mark（标记）-amp-reset方法" class="headerlink" title="mark（标记）&amp;reset方法"></a>mark（标记）&amp;reset方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer b1 = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">b1.put((<span class="keyword">byte</span>) <span class="number">11</span>);</span><br><span class="line">b1.mark();</span><br><span class="line">b1.put((<span class="keyword">byte</span>) <span class="number">12</span>);</span><br><span class="line">b1.put((<span class="keyword">byte</span>) <span class="number">13</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;重置前：&quot;</span>+Arrays.toString(b1.array()));</span><br><span class="line">b1.reset();</span><br><span class="line">b1.put((<span class="keyword">byte</span>) <span class="number">14</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;重置后&quot;</span>+Arrays.toString(b1.array()));</span><br></pre></td></tr></table></figure>

<p>标记只有配合reset方法才有效果，reset方法会把当前position位置修改到Mark的位置上。</p>
<p>如果没有mark标记，而直接使用reset方法会报InvalidMarkException异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer b1 = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">b1.put((<span class="keyword">byte</span>) <span class="number">11</span>);</span><br><span class="line"><span class="comment">//        b1.mark();</span></span><br><span class="line">b1.put((<span class="keyword">byte</span>) <span class="number">12</span>);</span><br><span class="line">b1.put((<span class="keyword">byte</span>) <span class="number">13</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;重置前：&quot;</span>+Arrays.toString(b1.array()));</span><br><span class="line">b1.reset();</span><br><span class="line">b1.put((<span class="keyword">byte</span>) <span class="number">14</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;重置后&quot;</span>+Arrays.toString(b1.array()));</span><br></pre></td></tr></table></figure>



<h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><h5 id="remaining"><a href="#remaining" class="headerlink" title="remaining()"></a>remaining()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer b1 = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">b1.put((<span class="keyword">byte</span>) <span class="number">11</span>);</span><br><span class="line">b1.put((<span class="keyword">byte</span>) <span class="number">12</span>);</span><br><span class="line">b1.put((<span class="keyword">byte</span>) <span class="number">13</span>);</span><br><span class="line">b1.limit(<span class="number">5</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;获取position与limit之间的元素数&quot;</span>+b1.remaining());<span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>获取position与limit之间的元素数</p>
<h5 id="isReadOnly"><a href="#isReadOnly" class="headerlink" title="isReadOnly()"></a>isReadOnly()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer b1 = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">b1.put((<span class="keyword">byte</span>) <span class="number">11</span>);</span><br><span class="line">b1.put((<span class="keyword">byte</span>) <span class="number">12</span>);</span><br><span class="line">b1.put((<span class="keyword">byte</span>) <span class="number">13</span>);</span><br><span class="line">System.out.println(b1.isReadOnly());<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>要获得一个只读缓冲区，需要调用asReadOnlyBuffer方法创建，不过在Buffer中他是一个抽象方法。</p>
<h5 id="isDirect"><a href="#isDirect" class="headerlink" title="isDirect()"></a>isDirect()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer b1 = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">System.out.println(b1.isDirect());<span class="comment">//flase</span></span><br><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocateDirect(<span class="number">10</span>);</span><br><span class="line">System.out.println(byteBuffer.isDirect());<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h5 id="rewind"><a href="#rewind" class="headerlink" title="rewind()"></a>rewind()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer b1 = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">b1.put((<span class="keyword">byte</span>) <span class="number">11</span>);</span><br><span class="line">b1.put((<span class="keyword">byte</span>) <span class="number">12</span>);</span><br><span class="line">b1.put((<span class="keyword">byte</span>) <span class="number">13</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;倒带缓冲区前&quot;</span>+b1.position());</span><br><span class="line">b1.rewind();</span><br><span class="line">System.out.println(<span class="string">&quot;倒带缓冲区后&quot;</span>b1.position());</span><br></pre></td></tr></table></figure>

<p>将position位置设置为：0，限制limit不变。丢弃标记。</p>
<h5 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer b1 = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">b1.put((<span class="keyword">byte</span>) <span class="number">11</span>);</span><br><span class="line">b1.put((<span class="keyword">byte</span>) <span class="number">12</span>);</span><br><span class="line">b1.put((<span class="keyword">byte</span>) <span class="number">13</span>);</span><br><span class="line">b1.limit(<span class="number">7</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;clear前: &quot;</span>+b1);</span><br><span class="line">System.out.println(Arrays.toString(b1.array()));</span><br><span class="line">b1.clear();</span><br><span class="line">System.out.println(<span class="string">&quot;clear后: &quot;</span>+b1);</span><br><span class="line">System.out.println(Arrays.toString(b1.array()));</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clear前: java.nio.HeapByteBuffer[pos=3 lim=7 cap=10]</span><br><span class="line">[11, 12, 13, 0, 0, 0, 0, 0, 0, 0]</span><br><span class="line">clear后: java.nio.HeapByteBuffer[pos=0 lim=10 cap=10]</span><br><span class="line">[11, 12, 13, 0, 0, 0, 0, 0, 0, 0]</span><br></pre></td></tr></table></figure>

<p>还原缓冲区position、limit、mark最初的状态，数据不变。</p>
<h5 id="flip"><a href="#flip" class="headerlink" title="flip()"></a>flip()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer b1 = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">b1.put((<span class="keyword">byte</span>) <span class="number">11</span>);</span><br><span class="line">b1.put((<span class="keyword">byte</span>) <span class="number">12</span>);</span><br><span class="line">b1.put((<span class="keyword">byte</span>) <span class="number">13</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;翻转前：&quot;</span>+b1);</span><br><span class="line">b1.flip();</span><br><span class="line">System.out.println(<span class="string">&quot;翻转后：&quot;</span>+b1);</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">翻转前：java.nio.HeapByteBuffer[pos=3 lim=10 cap=10]</span><br><span class="line">翻转后：java.nio.HeapByteBuffer[pos=0 lim=3 cap=10]</span><br></pre></td></tr></table></figure>

</div><div class="p-copyright"><blockquote><div class="p-copyright-author"><span class="p-copyright-key">本文作者：</span><span class="p-copytight-value"><a href="mailto:litreily@163.com">willardTeriberka</a></span></div><div class="p-copyright-link"><span class="p-copyright-key">本文链接：</span><span class="p-copytight-value"><a href="/2019/04/24/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-NIO%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA/">http://willardteriberka.gitee.io/2019/04/24/Java网络编程-NIO之缓冲区/</a></span></div><div class="p-copyright-note"><span class="p-copyright-key">版权声明：</span><span class="p-copytight-value">本博客所有文章除特殊声明外，均采用<a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/"> CC BY-NC 4.0 </a>许可协议。转载请注明出处 <a href="http://willardteriberka.gitee.io">willardTeriberka的博客</a>！</span></div></blockquote></div></article><div class="p-info box"><span class="p-tags"><i class="fa fa-tag"></i><a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a></span></div><aside id="toc"><div class="toc-title">目录</div><nav><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#NIO"><span class="toc-number">1.</span> <span class="toc-text">NIO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">NIO概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.2.</span> <span class="toc-text">缓冲区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#buffer%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">1.2.1.</span> <span class="toc-text">buffer的种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E7%A7%8D%E7%B1%BB%EF%BC%9A"><span class="toc-number">1.2.2.</span> <span class="toc-text">缓冲区的种类：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.3.</span> <span class="toc-text">常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">创建缓冲区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">添加数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E9%87%8F%EF%BC%88capacity%EF%BC%89"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">容量（capacity）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%90%E5%88%B6%EF%BC%88limit%EF%BC%89"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">限制（limit）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E7%BD%AE%EF%BC%88position%EF%BC%89"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">位置（position）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mark%EF%BC%88%E6%A0%87%E8%AE%B0%EF%BC%89-amp-reset%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.3.6.</span> <span class="toc-text">mark（标记）&amp;reset方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.3.7.</span> <span class="toc-text">其他方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#remaining"><span class="toc-number">1.2.3.7.1.</span> <span class="toc-text">remaining()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#isReadOnly"><span class="toc-number">1.2.3.7.2.</span> <span class="toc-text">isReadOnly()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#isDirect"><span class="toc-number">1.2.3.7.3.</span> <span class="toc-text">isDirect()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rewind"><span class="toc-number">1.2.3.7.4.</span> <span class="toc-text">rewind()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#clear"><span class="toc-number">1.2.3.7.5.</span> <span class="toc-text">clear()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#flip"><span class="toc-number">1.2.3.7.6.</span> <span class="toc-text">flip()</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></nav></aside></div><section class="p-ext"><div class="l-pager l-pager-dtl box"><a class="prev" href="/2020/10/07/hello-world/">&lt; Hello World</a><a class="next" href="/2019/04/24/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-equals/">源码分析-equals方法 &gt;</a></div></section><footer><p>Copyright © 2016 - 2021 <a href="/." rel="nofollow">willardteriberka</a> | <strong><a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a></strong><br><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span></span> <span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span></span> | Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a>Theme with<a rel="nofollow" target="_blank" href="https://github.com/litreily/snark-hexo"> snark.</a></p></footer></div></div></div><script type="text/javascript" src="/plugins/prettify/prettify.js"></script><script type="text/javascript" src="/js/search.js"></script><script type="text/javascript" src="/js/top.js"></script><script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
    search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script></body></html>